<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
  Overview &ndash; type-inference-engine
</title>
    <link rel="stylesheet" href="static/style.css"/>
    
  <link rel="stylesheet" href="static/highlight.css"/>
  <script src="static/highlight.js"></script>
  <script src="static/load-mathjax.js" async></script>
  <style>
   /* Highlight the current top-level TOC item, and hide the TOC of all other items */

   .toc a[data-node="index"] {
       /*color: #AD3108;*/
   }

   .toc ol {
       display: none;
   }

   .toc li a[data-node="index"] {
       font-weight: bold;
   }

   .toc li a[data-node="index"] + ol {
       display: block;
   }

   .toc li a[data-node="index"] + ol li {
       margin-left: 10px;
   }
  </style>

  </head>
  <body>
    
  <h1 class="doc-title">type-inference-engine</h1>
  <article id="article" data-section="index">
    <aside>
      <ol class="toc"><li><a href="index.html" data-node="index">Overview</a></li><li><a href="lang.html" data-node="lang">Language of expressions</a></li><li><a href="type-system.html" data-node="type-system">Type systems</a></li><li><a href="known-functions.html" data-node="known-functions">Known functions</a></li><li><a href="inference.html" data-node="inference">Type inference problem</a></li><li><a href="literals.html" data-node="literals">Literals</a></li><li><a href="api.html" data-node="api">API</a><ol><li><a href="conditions.html" data-node="conditions">Conditions</a></li><li><a href="0-type-system.html" data-node="0-type-system">Type system</a></li><li><a href="1-known-functions.html" data-node="1-known-functions">Known functions</a></li><li><a href="code-parsing.html" data-node="code-parsing">Code parsing</a></li><li><a href="type-inference.html" data-node="type-inference">Type inference</a></li></ol></li></ol>
    </aside>
    <main class="codex-section">
      <header>
        <h2 class="section-title">Overview</h2>
      </header>
      <div class="content">
        <p>
   This is a simple type inference engine based on the paper by Marc Kaplan and
   Jeffrey Ullman (see below). This engine features custom type systems based on
   subtyping, a simple language based on S-expressions and allows you to create
   basic functions to start type inferece with. There are some examples
   below. These examples use a toy type system and a set of known functions from
   <code>type-inference-engine/example</code> package. Do not be afraid if you do not
   understand them, they will be explained in futher sections.</p><p>   </p><pre><code class="lisp">(defpackage examples
  (:use #:cl)
  (:local-nicknames (#:tie    #:type-inference-engine)
                    (#:tie/ex #:type-inference-engine/example)))
(in-package :examples)

(tie/ex:infer-types '(+ x (sin y))) ;; =&gt;
((Y . #&lt;TIE:TYPE-NODE NUMBER {10155D1173}&gt;)
 (#:RES486 . #&lt;TIE:TYPE-NODE NUMBER {10155D1173}&gt;)
 (X . #&lt;TIE:TYPE-NODE NUMBER {10155D1173}&gt;)
 (#:VAR487 . #&lt;TIE:TYPE-NODE NUMBER {10155D1173}&gt;))
#:RES486
;; The first value is a mapping from variables used in the expression to their
;; corresponding types. Variables which begin with #:VAR are intermediate
;; variables which do not appear in the expression explicitly. The second value
;; is a name of variable which contains the result of evaluation of the
;; expression. All in all, the output of TIE/EX:INFER-TYPES can be read as: the
;; expression takes two arguments of type NUMBER and returns a result of type
;; NUMBER.

(tie/ex:infer-types '(1+ (sin (floor y)))) ;; =&gt;
((Y . #&lt;TIE:TYPE-NODE NUMBER {10155D1173}&gt;)
 (#:VAR501 . #&lt;TIE:TYPE-NODE INTEGER {10155D1113}&gt;)
 (#:RES499 . #&lt;TIE:TYPE-NODE FLOAT {10155D1143}&gt;)
 (#:VAR500 . #&lt;TIE:TYPE-NODE FLOAT {10155D1143}&gt;))
#:RES499
;; Here Y becomes rounded with FLOOR before SIN is calculated. As a
;; result the most narrow type of (SIN (FLOOR Y)) is FLOAT (which is a
;; type for real numbers in floating point representation), not NUMBER
;; (which is a type for numbers in general). Hence the whole
;; expression takes an argument of type NUMBER and returns a FLOAT.

(tie/ex:infer-types '(+ (length y)(- x (floor (elt y x))))) ;; =&gt;
((#:VAR517 . #&lt;TIE:TYPE-NODE NUMBER {10155D1173}&gt;)
 (Y . #&lt;TIE:TYPE-NODE SEQUENCE {10155D10B3}&gt;)
 (X . #&lt;TIE:TYPE-NODE INTEGER {10155D1113}&gt;)
 (#:VAR516 . #&lt;TIE:TYPE-NODE INTEGER {10155D1113}&gt;)
 (#:RES513 . #&lt;TIE:TYPE-NODE INTEGER {10155D1113}&gt;)
 (#:VAR514 . #&lt;TIE:TYPE-NODE INTEGER {10155D1113}&gt;)
 (#:VAR515 . #&lt;TIE:TYPE-NODE INTEGER {10155D1113}&gt;))
#:RES513
;; Here the most narrow type for Y is a SEQUENCE (one dimensional array-like
;; collection). X can only be an INTEGER as it serves a role of an index into Y
;; in (ELT Y X). The result has a type INTEGER, because both LENGTH and FLOOR
;; return an INTEGER.

(tie/ex:infer-types '(+ x (length x))) ;; =&gt;
((#:RES530 . #&lt;TIE:TYPE-NODE NIL {10155D0F93}&gt;)
 (X . #&lt;TIE:TYPE-NODE NIL {10155D0F93}&gt;)
 (#:VAR531 . #&lt;TIE:TYPE-NODE NIL {10155D0F93}&gt;))
#:RES530
;; The expression (+ x (length x)) maps values of type NIL to NIL which is a
;; special empty type, i.e. there are no such values for which the expression
;; can be evaluated. This is because X cannot be a number and a sequence at the
;; same time.

(tie/ex:infer-types '(if x (1+ (floor y))(sin z))) ;; =&gt;
((Y . #&lt;TIE:TYPE-NODE NUMBER {10155D1173}&gt;)
 (#:VAR549 . #&lt;TIE:TYPE-NODE INTEGER {10155D1113}&gt;)
 (Z . #&lt;TIE:TYPE-NODE NUMBER {10155D1173}&gt;)
 (#:RES546 . #&lt;TIE:TYPE-NODE NUMBER {10155D1173}&gt;)
 (X . #&lt;TIE:TYPE-NODE BOOLEAN {10155D11A3}&gt;)
 (#:VAR547 . #&lt;TIE:TYPE-NODE INTEGER {10155D1113}&gt;)
 (#:VAR548 . #&lt;TIE:TYPE-NODE NUMBER {10155D1173}&gt;))
#:RES546
;; This expression take a BOOLEAN x and returns a value of type NUMBER. IF is an
;; ordinary function in this example, i.e. it evaluates all its arguments and
;; returns either the second or the third argument depending on conditional.

(tie/ex:infer-types '(if (numberp (1+ x)) 3.2 4)) ;; =&gt;
((X . #&lt;TIE:TYPE-NODE NUMBER {10155D1173}&gt;)
 (#:VAR565 . #&lt;TIE:TYPE-NODE NUMBER {10155D1173}&gt;)
 (#:RES561 . #&lt;TIE:TYPE-NODE FLOAT {10155D1143}&gt;)
 (#:VAR562 . #&lt;TIE:TYPE-NODE TRUE {10155D1023}&gt;)
 (#:VAR563 . #&lt;TIE:TYPE-NODE FLOAT {10155D1143}&gt;)
 (#:VAR564 . #&lt;TIE:TYPE-NODE INTEGER {10155D1113}&gt;))
#:RES561
;; Here is an example of control flow analysis: (1+ X) is certainly a number, so
;; the result is of type FLOAT (the value 4 is never returned).

(tie/ex:-&gt; (%fac)(integer integer) integer)
(tie/ex:compile-function
 '(defun %fac (acc n)
   (if (zerop n) acc
       (%fac (* n acc)(1- n))))) ;; =&gt;
#S(TIE::SIMPLE-KNOWN-FUNCTION
   :NAME %FAC
   :ARG-TYPES (#&lt;TIE:TYPE-NODE INTEGER {10155D1113}&gt;
               #&lt;TIE:TYPE-NODE INTEGER {10155D1113}&gt;)
   :RES-TYPE #&lt;TIE:TYPE-NODE INTEGER {10155D1113}&gt;)
(tie/ex:compile-function
 '(defun fac (n)(%fac 1 n))) ;; =&gt;
#S(TIE::SIMPLE-KNOWN-FUNCTION
   :NAME FAC
   :ARG-TYPES (#&lt;TIE:TYPE-NODE INTEGER {10155D1113}&gt;)
   :RES-TYPE #&lt;TIE:TYPE-NODE INTEGER {10155D1113}&gt;)
(tie/ex:compile-function
 '(defun c (n m)
   (/ (fac n)(* (fac m)(fac (- n m)))))) ;; =&gt;
#S(TIE::SIMPLE-KNOWN-FUNCTION
   :NAME C
   :ARG-TYPES (#&lt;TIE:TYPE-NODE INTEGER {10155D1113}&gt;
               #&lt;TIE:TYPE-NODE INTEGER {10155D1113}&gt;)
   :RES-TYPE #&lt;TIE:TYPE-NODE FLOAT {10155D1143}&gt;)
;; Here custom functions FAC (factorial) and C (binomial coefficient) are
;; created. If you are defining a recursive function, it has to be declared
;; first (i.e. type-inference-engine works only as a type checker here).
   </code></pre><p>
   For more understanding what is going on here, visit <a id="lang" href="lang.html" data-node="lang">language of
   expressions</a> and <a id="type-system" href="type-system.html" data-node="type-system">type system</a> sections.</p><p>   Reference to the paper: Marc A. Kaplan and Jeffrey D. Ullman. 1978. A general
   scheme for the automatic inference of variable types. In Proceedings of the
   5th ACM SIGACT-SIGPLAN symposium on Principles of programming languages (POPL
   '78). Association for Computing Machinery, New York, NY, USA,
   60â€“75. https://doi.org/10.1145/512760.512768
</p>
      </div>
    </main>
  </article>
  <footer>
    <div class="info">
      Created with <a href="https://github.com/CommonDoc/codex">Codex</a>.
    </div>
  </footer>
  <script>
   HighlightLisp.highlight_auto();
  </script>

  </body>
</html>
