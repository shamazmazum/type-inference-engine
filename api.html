<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
  API &ndash; type-inference-engine
</title>
    <link rel="stylesheet" href="static/style.css"/>
    
  <link rel="stylesheet" href="static/highlight.css"/>
  <script src="static/highlight.js"></script>
  <script src="static/load-mathjax.js" async></script>
  <style>
   /* Highlight the current top-level TOC item, and hide the TOC of all other items */

   .toc a[data-node="api"] {
       /*color: #AD3108;*/
   }

   .toc ol {
       display: none;
   }

   .toc li a[data-node="api"] {
       font-weight: bold;
   }

   .toc li a[data-node="api"] + ol {
       display: block;
   }

   .toc li a[data-node="api"] + ol li {
       margin-left: 10px;
   }
  </style>

  </head>
  <body>
    
  <h1 class="doc-title">type-inference-engine</h1>
  <article id="article" data-section="api">
    <aside>
      <ol class="toc"><li><a href="index.html" data-node="index">Overview</a></li><li><a href="lang.html" data-node="lang">Language of expressions</a></li><li><a href="type-system.html" data-node="type-system">Type systems</a></li><li><a href="known-functions.html" data-node="known-functions">Known functions</a></li><li><a href="inference.html" data-node="inference">Type inference problem</a></li><li><a href="literals.html" data-node="literals">Literals</a></li><li><a href="api.html" data-node="api">API</a><ol><li><a href="api.html#conditions" data-node="conditions">Conditions</a></li><li><a href="api.html#0-type-system" data-node="0-type-system">Type system</a></li><li><a href="api.html#1-known-functions" data-node="1-known-functions">Known functions</a></li><li><a href="api.html#code-parsing" data-node="code-parsing">Code parsing</a></li><li><a href="api.html#type-inference" data-node="type-inference">Type inference</a></li></ol></li></ol>
    </aside>
    <main class="codex-section">
      <header>
        <h2 class="section-title">API</h2>
      </header>
      <div class="content">
        
   <h1 id="conditions">Conditions</h1>
      
         <div class="codex-doc-node codex-record codex-condition"><code class="codex-name">inference-error</code><div class="codex-docstring">General type inference error</div><ul class="codex-slot-list"></ul></div>
         <div class="codex-doc-node codex-record codex-condition"><code class="codex-name">cycle-detected</code><div class="codex-docstring">Signaled when a cycle is detected during a graph
traversal and that graph cannot contain cycles.</div><ul class="codex-slot-list"><li class="codex-slot codex-class-slot"><code class="codex-name">node</code><div class="codex-docstring">An already seen node</div><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Allocation:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell">instance</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initarg:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">:node</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Readers:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">(cycle-detected-node)</code></td></tr></table></div></li></ul></div>
         <div class="codex-doc-node codex-record codex-condition"><code class="codex-name">typesystem-error</code><div class="codex-docstring">Signaled when a type system is defined
incorrectly.</div><ul class="codex-slot-list"><li class="codex-slot codex-class-slot"><code class="codex-name">type-system</code><div class="codex-docstring">A top node of the type system</div><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Allocation:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell">instance</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initarg:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">:type-system</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Readers:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">(typesystem-error-system)</code></td></tr></table></div></li></ul></div>
         <div class="codex-doc-node codex-record codex-condition"><code class="codex-name">incorrect-definition</code><div class="codex-docstring">Signaled when type inference function is defined
incorrectly.</div><ul class="codex-slot-list"></ul></div>
         <div class="codex-doc-node codex-record codex-condition"><code class="codex-name">arity-error</code><div class="codex-docstring">Signaled when a known function is called with wrong
number of arguments.</div><ul class="codex-slot-list"><li class="codex-slot codex-class-slot"><code class="codex-name">actual-arity</code><div class="codex-docstring">Arity of a function seen in the code</div><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Allocation:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell">instance</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">alexandria:non-negative-fixnum</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initarg:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">:actual</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Readers:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">(actual-arity)</code></td></tr></table></div></li><li class="codex-slot codex-class-slot"><code class="codex-name">expected-arity</code><div class="codex-docstring">Arity of a function in FNDB</div><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Allocation:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell">instance</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">alexandria:non-negative-fixnum</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initarg:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">:expected</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Readers:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">(expected-arity)</code></td></tr></table></div></li></ul></div>
         <div class="codex-doc-node codex-record codex-condition"><code class="codex-name">unknown-function</code><div class="codex-docstring">Signaled when an unknown function is called in the
code which needs to be type-checked.</div><ul class="codex-slot-list"></ul></div>
         <div class="codex-doc-node codex-record codex-condition"><code class="codex-name">unknown-literal</code><div class="codex-docstring">Signaled when S-expression looks like a literal but
its type cannot be determined.</div><ul class="codex-slot-list"><li class="codex-slot codex-class-slot"><code class="codex-name">code</code><div class="codex-docstring">An expression which contains unknown literal</div><div class="codex-class-struct-slot-option-node"><table class="codex-class-struct-slot-option-table"><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-header-cell">Option</td><td class="codex-class-struct-slot-option-header-cell">Value</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Allocation:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell">instance</td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Type:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">nil</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Initarg:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">:code</code></td></tr><tr class="codex-class-struct-slot-option-row"><td class="codex-class-struct-slot-option-label-cell">Readers:</td><td class="codex-class-struct-slot-option-value-cell codex-class-struct-slot-option-symbol-list-cell"><code class="codex-class-struct-slot-symbol-list">(unknown-literal-code)</code></td></tr></table></div></li></ul></div>
         <div class="codex-doc-node codex-record codex-condition"><code class="codex-name">fndb-entry-exists</code><div class="codex-docstring">Signaled when you want to place an entry in fndb
which tries to overwrite another existing entry.</div><ul class="codex-slot-list"></ul></div>
      
   
   <h1 id="0-type-system">Type system</h1>
      During to serapeum limitations, the type <code>type-node</code> and the
      corresponding constructor cannot be documented. Look at examples in
      <a id="type-system" href="type-system.html" data-node="type-system">this</a> section.
      
         <div class="codex-doc-node codex-type"><code class="codex-name">type-node-order</code><code class="codex-type-def">nil</code><div class="codex-docstring">An order between two types. Can be <code>:EQ</code>, <code>:LT</code>, <code>:GT</code> or
<code>NIL</code>. The latter is to indicate that there is no order between two
types.</div></div>
         <div class="codex-doc-node codex-operator codex-function"><code class="codex-name">le</code><code class="codex-lambda-list">(order)</code><div class="codex-docstring">Return <code>t</code> if <code>order</code> is either <code>:eq</code> or <code>:lt</code>, <code>nil</code>
otherwise.</div></div>
         <div class="codex-doc-node codex-operator codex-function"><code class="codex-name">ge</code><code class="codex-lambda-list">(order)</code><div class="codex-docstring">Return <code>t</code> if <code>order</code> is either <code>:eq</code> or <code>:gt</code>, <code>nil</code>
otherwise.</div></div>
         <div class="codex-doc-node codex-operator codex-function"><code class="codex-name">type-node-order</code><code class="codex-lambda-list">(top t1 t2)</code><div class="codex-docstring">Return <code>:eq</code> when <code>t1 = t2</code>, <code>:lt</code> when <code>t1 &lt; t2</code>, <code>:gt</code>
when <code>t1 &gt; t2</code> or <code>nil</code> otherwise. <code>Top</code> is the top type of the
type system.</div></div>
         <div class="codex-doc-node codex-operator codex-function"><code class="codex-name">find-type-node</code><code class="codex-lambda-list">(name type-node)</code><div class="codex-docstring">Find a type node <code>A</code> which has the name <code>name</code> and <code>A ⊂
type-node</code>.</div></div>
         <div class="codex-doc-node codex-operator codex-function"><code class="codex-name">flatten-type-graph</code><code class="codex-lambda-list">(type-node)</code><div class="codex-docstring">Return a list of all types in a type system with the top node
<code>type-node</code>.</div></div>
         <div class="codex-doc-node codex-operator codex-function"><code class="codex-name">check-type-system</code><code class="codex-lambda-list">(type-node)</code><div class="codex-docstring">Return <code>type-node</code> if a type system for which this node is a top
node is defined correctly, otherwise signal <code>typesystem-error</code> or
just do not return control.</div></div>
         <div class="codex-doc-node codex-operator codex-function"><code class="codex-name">join</code><code class="codex-lambda-list">(top t1 t2)</code><div class="codex-docstring">Return the join of types <code>t1</code> and <code>t2</code>. Join <code>t</code> is the
minimal type for which <code>t1 ⊂ t</code> and <code>t2 ⊂ t</code>. <code>Top</code> is the top
type for the type system.</div></div>
         <div class="codex-doc-node codex-operator codex-function"><code class="codex-name">meet</code><code class="codex-lambda-list">(top t1 t2)</code><div class="codex-docstring">Return the meet of types <code>t1</code> and <code>t2</code>. Meet <code>t</code> is the
maximal type for which <code>t ⊂ t1</code> and <code>t ⊂ t2</code>. <code>Top</code> is the top
type for the type system.</div></div>
         <div class="codex-doc-node codex-operator codex-function"><code class="codex-name">types-intersect-p</code><code class="codex-lambda-list">(top t1 t2)</code><div class="codex-docstring">Return <code>t</code> if <code>t1 ∧ t2</code> is not the bottom type, <code>nil</code>
otherwise. <code>Top</code> is the top type of the type system.</div></div>
         <div class="codex-doc-node codex-operator codex-function"><code class="codex-name">print-graphviz-representation</code><code class="codex-lambda-list">(top &amp;optional (stream *standard-output*))</code><div class="codex-docstring">Print representation of a type system with the top node <code>top</code> in
Graphviz format to the output stream <code>stream</code>.</div></div>
      
   
   <h1 id="1-known-functions">Known functions</h1>
      
         <div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">defknown</code><code class="codex-lambda-list">(db top names arguments-clause type-bindings-clause (&amp;key (bottom-guard nil bottom-guard-p)) t0-cond-clauses &amp;optional t1+-cond-clauses)</code><div class="codex-docstring"><p>Add new known functions to the database <code>db</code>. <code>Top</code> is the top
type of a type system. <code>Names</code> is a list of function names to be
added. The new functions all have the same arity and the same
functions T₀, T₁, etc.<code>Type-bindings-clause</code> is a form <code>(arglist (result-variable
top-variable narg-variable))</code> and contains some important variables
which can be used in the body of functions T_i. <code>Arglist</code> is a list
of variables which are bound to types of arguments of the defined
functions. <code>Top-variable</code> is bound to the top type of a type-system,
<code>res-variable</code> is bound to type of the result of the defined
function and <code>narg-variable</code> is bound to i-1 in the body of T_i when
i &gt; 0.<code>Type-bindings-clause</code> is an associative list with entries in the
form <code>(variable-name . type-name)</code> which contains additional
bindings of variables to types inside T_i functions.<code>Bottom-guard</code> argument must always be present and be either <code>nil</code>
or name of a variable bound to the bottom type. If <code>bottom-guard</code> is
not null then bottom guards will be present in T_i functions.<code>T0-cond-clauses</code> define a body of function T₀ in which bindings to
<code>top-variable</code> and variables in <code>arglist</code> are in effect. This body
is an explicit cond, so <code>t0-cond-clauses</code> may be like this
</p><pre><code class="lisp">((condition-1 form-1)
 (condition-2 form-2)
 etc)
</code></pre><p>
<code>T0-cond-clauses</code> must evaluate to a type. If <code>bottom-guard</code> is
not <code>nil</code> an implicit conditional is inserted <i>before</i> all other
conditionals in cond. This conditional checks if any of variables in
<code>arglist</code> are bound to the bottom type, and if so the bottom type is
returned. Also another conditional is inserted <i>after</i> all other
conditionals which just returns the bottom type in any case.<code>T1+-cond-clauses</code> define a body of functions T₁, T₂, etc in which
bindings to <code>top-variable</code>, <code>res-variable</code>, <code>narg-variable</code> and
variables in <code>arglist</code> are in effect. This body is an explicit cond
and must evaluate to a type, just like <code>T0-cond-clauses</code>.</p><p>For example the following code
</p><pre><code class="lisp">(defknown *fndb* *type-system* (length)((x)(res top n))
  ((integer  . integer)
   (sequence . sequence)
   (bottom   . nil))
  (:bottom-guard bottom)
  ;; T₀
  (((types-intersect-p top x sequence) integer))
  ;; T₁
  (((ge (type-node-order top res integer))
    (meet top x sequence))))
</code></pre><p>
creates a function T₀
</p><pre><code class="lisp">(lambda (top x)
  (let ((integer  (find-type-node 'integer  top))
        (sequence (find-type-node 'sequence top))
        (bottom   (find-type-node nil       top)))
    (cond
      ((eq x bottom) bottom)
      ((types-intersect-p top x sequence) integer)
      (t bottom))))
</code></pre><p>
and T₁
</p><pre><code class="lisp">(lambda (top n res x)
  (assert (&lt; n 1))
  (let ((integer  (find-type-node 'integer  top))
        (sequence (find-type-node 'sequence top))
        (bottom   (find-type-node nil       top)))
    (cond
      ((or (eq x   bottom)
           (eq res bottom))
       bottom)
      ((ge (type-node-order top res integer))
       (meet top x sequence))
      (t bottom))))
</code></pre><p>
and adds a corresponding entry about the function <code>length</code> in
<code>*fndb*</code>.</p></div></div>
         <div class="codex-doc-node codex-operator codex-macro"><code class="codex-name">definitializer</code><code class="codex-lambda-list">(db top name type)</code><div class="codex-docstring">Add a function with the name <code>name</code> which takes zero arguments
and returns a value of type <code>type</code> to FNDB <code>db</code>
<pre><code class="lisp">(definitializer db top name type)
</code></pre>
is equivalent to
<pre><code class="lisp">(defknown db top (name)(() res top n)
  ((type-var . type))
  (:bottom-guard nil)
  ((t type-var))
  ())
</code></pre></div></div>
         <div class="codex-doc-node codex-operator codex-function"><code class="codex-name">make-fndb</code><code class="codex-lambda-list">(top-node)</code><div class="codex-docstring">Make a functions database for a type system with the top node
<code>top-node</code>.</div></div>
      
   
   <h1 id="code-parsing">Code parsing</h1>
      <b>NB</b>: This API is subject to change.
      
         <div class="codex-doc-node codex-operator codex-function"><code class="codex-name">parse-code</code><code class="codex-lambda-list">(code &amp;optional literal-initializers recursive-p)</code><div class="codex-docstring"><p>Parse an expression <code>code</code> and construct a control flow
graph. <code>Literal-initializers</code> is an associative list which contains
predicates as keys and initializer functions as values. When
<code>parse-code</code> sees a term of the expression, it runs predicates in
<code>literal-initializers</code>(in the order of appearance) on that term. If
a predicate returns <code>T</code> then that term is considered as a literal
and the corresponding initializer function is used to initialize a
constant variable with a value of type of the literal. For example:
</p><pre><code class="lisp">(parse-code '(+ x 3)) ; =&gt; Signals UNKNOWN-LITERAL
(parse-code
 '(+ x 3)
 (list
  (cons #'intergerp 'init/integer)))
;; =&gt;
;; #&lt;Node (#&lt;STATEMENT VAR254 ← (+ X CONST253) {1010A14543}&gt;) {1010A14563}&gt;
;; #:VAR254
</code></pre><p>This function returns a control flow graph and the name of a variable
where the result of expression is stored after evaluation of a
statement.</p></div></div>
         <div class="codex-doc-node codex-operator codex-function"><code class="codex-name">flat-control-flow-graph</code><code class="codex-lambda-list">(node)</code><div class="codex-docstring">Convert control flow graph returned from <code>parse-code</code> to a flat
representation understandable by <code>infer-types</code>.</div></div>
      
   
   <h1 id="type-inference">Type inference</h1>
      
         <div class="codex-doc-node codex-operator codex-function"><code class="codex-name">infer-types</code><code class="codex-lambda-list">(db top graph)</code><div class="codex-docstring">Get the best safe program-wide varible-&gt;type mappings for a control
flow graph in flat format returned by
<code>flat-control-flow-graph</code>. <code>Graph</code> is an internal representation
of an expression in the form of parallel assignment statements.
<code>Graph</code> can be obtained by firstly creating a control flow graph
from an expression by calling <code>parse-code</code> and secondly converting
it to flat format with <code>flat-control-flow-graph</code>. <code>Db</code> is a
database of known functions and <code>top</code> is the top type of your type
system. This function returns an array of variable-&gt;type mappings for
each parallel assignment statement in the flattened control flow
graph. The first element in that array is the most important as it
corresponds to a fully evaluated expression.</div></div>
      
   

      </div>
    </main>
  </article>
  <footer>
    <div class="info">
      Created with <a href="https://github.com/CommonDoc/codex">Codex</a>.
    </div>
  </footer>
  <script>
   HighlightLisp.highlight_auto();
  </script>

  </body>
</html>
